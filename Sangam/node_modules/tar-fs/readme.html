<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>readme.html</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<pre># tar-fs

filesystem bindings for [tar-stream](https://github.com/mafintosh/tar-stream).

```
npm install tar-fs
```

[![build status](https://secure.travis-ci.org/mafintosh/tar-fs.png)](http://travis-ci.org/mafintosh/tar-fs)

## Usage

tar-fs allows you to pack directories into tarballs and extract tarballs into directories.

It doesn&#x27;t gunzip for you, so if you want to extract a `.tar.gz` with this you&#x27;ll need to use something like [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe) in addition to this.

``` js
var tar = require(&#x27;tar-fs&#x27;)
var fs = require(&#x27;fs&#x27;)

// packing a directory
tar.pack(&#x27;./my-directory&#x27;).pipe(fs.createWriteStream(&#x27;my-tarball.tar&#x27;))

// extracting a directory
fs.createReadStream(&#x27;my-other-tarball.tar&#x27;).pipe(tar.extract(&#x27;./my-other-directory&#x27;))
```

To ignore various files when packing or extracting add a ignore function to the options. `ignore`
is also an alias for `filter`. Additionally you get `header` if you use ignore while extracting.
That way you could also filter by metadata.

``` js
var pack = tar.pack(&#x27;./my-directory&#x27;, {
  ignore: function(name) {
    return path.extname(name) === &#x27;.bin&#x27; // ignore .bin files when packing
  }
})

var extract = tar.extract(&#x27;./my-other-directory&#x27;, {
  ignore: function(name) {
    return path.extname(name) === &#x27;.bin&#x27; // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract(&#x27;./my-other-other-directory&#x27;, {
  ignore: function(_, header) {
    // pass files &amp; directories, ignore e.g. symlinks
    return header.type !== &#x27;file&#x27; &amp;&amp; header.type !== &#x27;directory&#x27;
  }
})
```

You can also specify which entries to pack using the `entries` option

```js
var pack = tar.pack(&#x27;./my-directory&#x27;, {
  entries: [&#x27;file1&#x27;, &#x27;subdir/file2&#x27;] // only the specific entries will be packed
})
```

If you want to modify the headers when packing/extracting add a map function to the options

``` js
var pack = tar.pack(&#x27;./my-directory&#x27;, {
  map: function(header) {
    header.name = &#x27;prefixed/&#x27;+header.name
    return header
  }
})

var extract = tar.extract(&#x27;./my-directory&#x27;, {
  map: function(header) {
    header.name = &#x27;another-prefix/&#x27;+header.name
    return header
  }
})
```

Similarly you can use `mapStream` incase you wanna modify the input/output file streams

``` js
var pack = tar.pack(&#x27;./my-directory&#x27;, {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === &#x27;.js&#x27;) {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract(&#x27;./my-directory&#x27;, {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === &#x27;.js&#x27;) {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
```

Set `options.fmode` and `options.dmode` to ensure that files/directories extracted have the corresponding modes

``` js
var extract = tar.extract(&#x27;./my-directory&#x27;, {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
```

It can be useful to use `dmode` and `fmode` if you are packing/unpacking tarballs between *nix/windows to ensure that all files/directories unpacked are readable.

Alternatively you can set `options.readable` and/or `options.writable` to set the dmode and fmode to readable/writable.

``` js
var extract = tar.extract(&#x27;./my-directory&#x27;, {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
```

Set `options.strict` to `false` if you want to ignore errors due to unsupported entry types (like device files)

To dereference symlinks (pack the contents of the symlink instead of the link itself) set `options.dereference` to `true`.

## Copy a directory

Copying a directory with permissions and mtime intact is as simple as

``` js
tar.pack(&#x27;source-directory&#x27;).pipe(tar.extract(&#x27;dest-directory&#x27;))
```

## Interaction with [`tar-stream`](https://github.com/mafintosh/tar-stream)

Use `finalize: false` and the `finish` hook to
leave the pack stream open for further entries (see
[`tar-stream#pack`](https://github.com/mafintosh/tar-stream#packing)),
and use `pack` to pass an existing pack stream.

``` js
var mypack = tar.pack(&#x27;./my-directory&#x27;, {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: &#x27;generated-file.txt&#x27;}, &quot;hello&quot;)
    tar.pack(&#x27;./other-directory&#x27;, {
      pack: sameAsMypack
    })
  }
})
```


## Performance

Packing and extracting a 6.1 GB with 2496 directories and 2398 files yields the following results on my Macbook Air.
[See the benchmark here](https://gist.github.com/mafintosh/8102201)

* tar-fs: 34.261 seconds
* [node-tar](https://github.com/isaacs/node-tar): 366.123 seconds (or 10x slower)

## License

MIT
</pre>
</body>
</html>