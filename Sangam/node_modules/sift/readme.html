<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>readme.html</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<pre>**Installation**: `npm install sift`, or `yarn add sift`

## Sift is a tiny library for using MongoDB queries in Javascript

[![Build Status](https://secure.travis-ci.org/crcn/sift.js.png)](https://secure.travis-ci.org/crcn/sift.js)

&lt;!-- [![Coverage Status](https://coveralls.io/repos/crcn/sift.js/badge.svg)](https://coveralls.io/r/crcn/sift.js)  --&gt;
&lt;!-- [![Join the chat at https://gitter.im/crcn/sift.js](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/crcn/sift.js?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge) --&gt;

**For extended documentation, checkout http://docs.mongodb.org/manual/reference/operator/query/**

## Features:

- Supported operators: [\$in](#in), [\$nin](#nin), [\$exists](#exists), [\$gte](#gte), [\$gt](#gt), [\$lte](#lte), [\$lt](#lt), [\$eq](#eq), [\$ne](#ne), [\$mod](#mod), [\$all](#all), [\$and](#and), [\$or](#or), [\$nor](#nor), [\$not](#not), [\$size](#size), [\$type](#type), [\$regex](#regex), [\$where](#where), [\$elemMatch](#elemmatch)
- Regexp searches
- Supports node.js, and web
- Custom Operations
- Tree-shaking (omitting functionality from web app bundles)

## Examples

```javascript
import sift from &quot;sift&quot;;

// intersecting arrays
const result1 = [&quot;hello&quot;, &quot;sifted&quot;, &quot;array!&quot;].filter(
  sift({ $in: [&quot;hello&quot;, &quot;world&quot;] }),
); // [&#x27;hello&#x27;]

// regexp filter
const result2 = [&quot;craig&quot;, &quot;john&quot;, &quot;jake&quot;].filter(sift(/^j/)); //[&#x27;john&#x27;,&#x27;jake&#x27;]

// function filter
const testFilter = sift({
  //you can also filter against functions
  name: function (value) {
    return value.length == 5;
  },
});

const result3 = [
  {
    name: &quot;craig&quot;,
  },
  {
    name: &quot;john&quot;,
  },
  {
    name: &quot;jake&quot;,
  },
].filter(testFilter); // filtered: [{ name: &#x27;craig&#x27; }]

// you can test *single values* against your custom sifter
testFilter({ name: &quot;sarah&quot; }); //true
testFilter({ name: &quot;tim&quot; }); //false
```

## API

### sift(query: MongoQuery, options?: Options): Function

Creates a filter with all the built-in MongoDB query operations.

- `query` - the filter to use against the target array
- `options`
  - `operations` - [custom operations](#custom-operations)
  - `compare` - compares difference between two values

Example:

```javascript
import sift from &quot;sift&quot;;

const test = sift({ $gt: 5 });

console.log(test(6)); // true
console.log(test(4)); // false

[3, 4, 5, 6, 7].filter(test); // [6, 7]
```

### createQueryTester(query: Query, options?: Options): Function

Creates a filter function **without** built-in MongoDB query operations. This is useful
if you&#x27;re looking to omit certain operations from application bundles. See [Omitting built-in operations](#omitting-built-in-operations) for more info.

```javascript
import { createQueryTester, $eq, $in } from &quot;sift&quot;;
const filter = createQueryTester({ $eq: 5 }, { operations: { $eq, $in } });
```

### createEqualsOperation(params: any, ownerQuery: Query, options: Options): Operation

Used for [custom operations](#custom-operations).

```javascript
import { createQueryTester, createEqualsOperation, $eq, $in } from &quot;sift&quot;;
const filter = createQueryTester(
  { $mod: 5 },
  {
    operations: {
      $something(mod, ownerQuery, options) {
        return createEqualsOperation(
          (value) =&gt; value % mod === 0,
          ownerQuery,
          options,
        );
      },
    },
  },
);
filter(10); // true
filter(11); // false
```

## Supported Operators

See MongoDB&#x27;s [advanced queries](http://www.mongodb.org/display/DOCS/Advanced+Queries) for more info.

### \$in

array value must be _\$in_ the given query:

Intersecting two arrays:

```javascript
// filtered: [&#x27;Brazil&#x27;]
[&quot;Brazil&quot;, &quot;Haiti&quot;, &quot;Peru&quot;, &quot;Chile&quot;].filter(
  sift({ $in: [&quot;Costa Rica&quot;, &quot;Brazil&quot;] }),
);
```

Here&#x27;s another example. This acts more like the \$or operator:

```javascript
[{ name: &quot;Craig&quot;, location: &quot;Brazil&quot; }].filter(
  sift({ location: { $in: [&quot;Costa Rica&quot;, &quot;Brazil&quot;] } }),
);
```

### \$nin

Opposite of \$in:

```javascript
// filtered: [&#x27;Haiti&#x27;,&#x27;Peru&#x27;,&#x27;Chile&#x27;]
[&quot;Brazil&quot;, &quot;Haiti&quot;, &quot;Peru&quot;, &quot;Chile&quot;].filter(
  sift({ $nin: [&quot;Costa Rica&quot;, &quot;Brazil&quot;] }),
);
```

### \$exists

Checks if whether a value exists:

```javascript
// filtered: [&#x27;Craig&#x27;,&#x27;Tim&#x27;]
sift({ $exists: true })([&quot;Craig&quot;, null, &quot;Tim&quot;]);
```

You can also filter out values that don&#x27;t exist

```javascript
// filtered: [{ name: &quot;Tim&quot; }]
[{ name: &quot;Craig&quot;, city: &quot;Minneapolis&quot; }, { name: &quot;Tim&quot; }].filter(
  sift({ city: { $exists: false } }),
);
```

### \$gte

Checks if a number is &gt;= value:

```javascript
// filtered: [2, 3]
[0, 1, 2, 3].filter(sift({ $gte: 2 }));
```

### \$gt

Checks if a number is &gt; value:

```javascript
// filtered: [3]
[0, 1, 2, 3].filter(sift({ $gt: 2 }));
```

### \$lte

Checks if a number is &lt;= value.

```javascript
// filtered: [0, 1, 2]
[0, 1, 2, 3].filter(sift({ $lte: 2 }));
```

### \$lt

Checks if number is &lt; value.

```javascript
// filtered: [0, 1]
[0, 1, 2, 3].filter(sift({ $lt: 2 }));
```

### \$eq

Checks if `query === value`. Note that **\$eq can be omitted**. For **\$eq**, and **\$ne**

```javascript
// filtered: [{ state: &#x27;MN&#x27; }]
[{ state: &quot;MN&quot; }, { state: &quot;CA&quot; }, { state: &quot;WI&quot; }].filter(
  sift({ state: { $eq: &quot;MN&quot; } }),
);
```

Or:

```javascript
// filtered: [{ state: &#x27;MN&#x27; }]
[{ state: &quot;MN&quot; }, { state: &quot;CA&quot; }, { state: &quot;WI&quot; }].filter(
  sift({ state: &quot;MN&quot; }),
);
```

### \$ne

Checks if `query !== value`.

```javascript
// filtered: [{ state: &#x27;CA&#x27; }, { state: &#x27;WI&#x27;}]
[{ state: &quot;MN&quot; }, { state: &quot;CA&quot; }, { state: &quot;WI&quot; }].filter(
  sift({ state: { $ne: &quot;MN&quot; } }),
);
```

### \$mod

Modulus:

```javascript
// filtered: [300, 600]
[100, 200, 300, 400, 500, 600].filter(sift({ $mod: [3, 0] }));
```

### \$all

values must match **everything** in array:

```javascript
// filtered: [ { tags: [&#x27;books&#x27;,&#x27;programming&#x27;,&#x27;travel&#x27; ]} ]
[
  { tags: [&quot;books&quot;, &quot;programming&quot;, &quot;travel&quot;] },
  { tags: [&quot;travel&quot;, &quot;cooking&quot;] },
].filter(sift({ tags: { $all: [&quot;books&quot;, &quot;programming&quot;] } }));
```

### \$and

ability to use an array of expressions. All expressions must test true.

```javascript
// filtered: [ { name: &#x27;Craig&#x27;, state: &#x27;MN&#x27; }]

[
  { name: &quot;Craig&quot;, state: &quot;MN&quot; },
  { name: &quot;Tim&quot;, state: &quot;MN&quot; },
  { name: &quot;Joe&quot;, state: &quot;CA&quot; },
].filter(sift({ $and: [{ name: &quot;Craig&quot; }, { state: &quot;MN&quot; }] }));
```

### \$or

OR array of expressions.

```javascript
// filtered: [ { name: &#x27;Craig&#x27;, state: &#x27;MN&#x27; }, { name: &#x27;Tim&#x27;, state: &#x27;MN&#x27; }]
[
  { name: &quot;Craig&quot;, state: &quot;MN&quot; },
  { name: &quot;Tim&quot;, state: &quot;MN&quot; },
  { name: &quot;Joe&quot;, state: &quot;CA&quot; },
].filter(sift({ $or: [{ name: &quot;Craig&quot; }, { state: &quot;MN&quot; }] }));
```

### \$nor

opposite of or:

```javascript
// filtered: [{ name: &#x27;Joe&#x27;, state: &#x27;CA&#x27; }]
[
  { name: &quot;Craig&quot;, state: &quot;MN&quot; },
  { name: &quot;Tim&quot;, state: &quot;MN&quot; },
  { name: &quot;Joe&quot;, state: &quot;CA&quot; },
].filter(sift({ $nor: [{ name: &quot;Craig&quot; }, { state: &quot;MN&quot; }] }));
```

### \$size

Matches an array - must match given size:

```javascript
// filtered: [&#x27;food&#x27;,&#x27;cooking&#x27;]
[{ tags: [&quot;food&quot;, &quot;cooking&quot;] }, { tags: [&quot;traveling&quot;] }].filter(
  sift({ tags: { $size: 2 } }),
);
```

### \$type

Matches a values based on the type

```javascript
[new Date(), 4342, &quot;hello world&quot;].filter(sift({ $type: Date })); // returns single date
[new Date(), 4342, &quot;hello world&quot;].filter(sift({ $type: String })); // returns [&#x27;hello world&#x27;]
```

### \$regex

Matches values based on the given regular expression

```javascript
[&quot;frank&quot;, &quot;fred&quot;, &quot;sam&quot;, &quot;frost&quot;].filter(
  sift({ $regex: /^f/i, $nin: [&quot;frank&quot;] }),
); // [&quot;fred&quot;, &quot;frost&quot;]
[&quot;frank&quot;, &quot;fred&quot;, &quot;sam&quot;, &quot;frost&quot;].filter(
  sift({ $regex: &quot;^f&quot;, $options: &quot;i&quot;, $nin: [&quot;frank&quot;] }),
); // [&quot;fred&quot;, &quot;frost&quot;]
```

### \$where

Matches based on some javascript comparison

```javascript
[{ name: &quot;frank&quot; }, { name: &quot;joe&quot; }].filter(
  sift({ $where: &quot;this.name === &#x27;frank&#x27;&quot; }),
); // [&quot;frank&quot;]
[{ name: &quot;frank&quot; }, { name: &quot;joe&quot; }].filter(
  sift({
    $where: function () {
      return this.name === &quot;frank&quot;;
    },
  }),
); // [&quot;frank&quot;]
```

### \$elemMatch

Matches elements of array

```javascript
var bills = [
  {
    month: &quot;july&quot;,
    casts: [
      {
        id: 1,
        value: 200,
      },
      {
        id: 2,
        value: 1000,
      },
    ],
  },
  {
    month: &quot;august&quot;,
    casts: [
      {
        id: 3,
        value: 1000,
      },
      {
        id: 4,
        value: 4000,
      },
    ],
  },
];

var result = bills.filter(
  sift({
    casts: {
      $elemMatch: {
        value: { $gt: 1000 },
      },
    },
  }),
); // {month:&#x27;august&#x27;, casts:[{id:3, value: 1000},{id: 4, value: 4000}]}
```

### \$not

Not expression:

```javascript
[&quot;craig&quot;, &quot;tim&quot;, &quot;jake&quot;].filter(sift({ $not: { $in: [&quot;craig&quot;, &quot;tim&quot;] } })); // [&#x27;jake&#x27;]
[&quot;craig&quot;, &quot;tim&quot;, &quot;jake&quot;].filter(sift({ $not: { $size: 5 } })); // [&#x27;tim&#x27;,&#x27;jake&#x27;]
```

### Date comparison

Mongodb allows you to do date comparisons like so:

```javascript
db.collection.find({ createdAt: { $gte: &quot;2018-03-22T06:00:00Z&quot; } });
```

In Sift, you&#x27;ll need to specify a Date object:

```javascript
collection.find(
  sift({ createdAt: { $gte: new Date(&quot;2018-03-22T06:00:00Z&quot;) } }),
);
```

## Custom behavior

Sift works like MongoDB out of the box, but you&#x27;re also able to modify the behavior to suite your needs.

#### Custom operations

You can register your own custom operations. Here&#x27;s an example:

```javascript
import sift, { createEqualsOperation } from &quot;sift&quot;;

var filter = sift(
  {
    $customMod: 2,
  },
  {
    operations: {
      $customMod(params, ownerQuery, options) {
        return createEqualsOperation(
          (value) =&gt; value % params !== 0,
          ownerQuery,
          options,
        );
      },
    },
  },
);

[1, 2, 3, 4, 5].filter(filter); // [1, 3, 5]
```

#### Omitting built-in operations

You can create a filter function that omits the built-in operations like so:

```javascript
import { createQueryTester, $in, $all, $nin, $lt } from &quot;sift&quot;;
const test = createQueryTester(
  {
    $eq: 10,
  },
  { operations: { $in, $all, $nin, $lt } },
);

[1, 2, 3, 4, 10].filter(test);
```

For bundlers like `Webpack` and `Rollup`, operations that aren&#x27;t used are omitted from application bundles via tree-shaking.
</pre>
</body>
</html>