<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>readme.html</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<pre># minipass-flush

A Minipass stream that calls a flush function before emitting &#x27;end&#x27;

## USAGE

```js
const Flush = require(&#x27;minipass-flush&#x27;)
cons f = new Flush({
  flush (cb) {
    // call the cb when done, or return a promise
    // the &#x27;end&#x27; event will wait for it, along with
    // close, finish, and prefinish.
    // call the cb with an error, or return a rejecting
    // promise to emit &#x27;error&#x27; instead of doing the &#x27;end&#x27;
    return rerouteAllEncryptions().then(() =&gt; clearAllChannels())
  },
  // all other minipass options accepted as well
})

someDataSource.pipe(f).on(&#x27;end&#x27;, () =&gt; {
  // proper flushing has been accomplished
})

// Or as a subclass implementing a &#x27;flush&#x27; method:
class MyFlush extends Flush {
  flush (cb) {
    // old fashioned callback style!
    rerouteAllEncryptions(er =&gt; {
      if (er)
        return cb(er)
      clearAllChannels(er =&gt; {
        if (er)
          cb(er)
        cb()
      })
    })
  }
}
```

That&#x27;s about it.

If your `flush` method doesn&#x27;t have to do anything asynchronous, then it&#x27;s
better to call the callback right away in this tick, rather than returning
`Promise.resolve()`, so that the `end` event can happen as soon as
possible.
</pre>
</body>
</html>