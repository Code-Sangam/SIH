<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>readme.html</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<pre># tar-stream

tar-stream is a streaming tar parser and generator and nothing else. It is streams2 and operates purely using streams which means you can easily extract/parse tarballs without ever hitting the file system.

Note that you still need to gunzip your data if you have a `.tar.gz`. We recommend using [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe) in conjunction with this.

```
npm install tar-stream
```

[![build status](https://secure.travis-ci.org/mafintosh/tar-stream.png)](http://travis-ci.org/mafintosh/tar-stream)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](http://opensource.org/licenses/MIT)

## Usage

tar-stream exposes two streams, [pack](https://github.com/mafintosh/tar-stream#packing) which creates tarballs and [extract](https://github.com/mafintosh/tar-stream#extracting) which extracts tarballs. To [modify an existing tarball](https://github.com/mafintosh/tar-stream#modifying-existing-tarballs) use both.


It implementes USTAR with additional support for pax extended headers. It should be compatible with all popular tar distributions out there (gnutar, bsdtar etc)

## Related

If you want to pack/unpack directories on the file system check out [tar-fs](https://github.com/mafintosh/tar-fs) which provides file system bindings to this module.

## Packing

To create a pack stream use `tar.pack()` and call `pack.entry(header, [callback])` to add tar entries.

``` js
var tar = require(&#x27;tar-stream&#x27;)
var pack = tar.pack() // pack is a streams2 stream

// add a file called my-test.txt with the content &quot;Hello World!&quot;
pack.entry({ name: &#x27;my-test.txt&#x27; }, &#x27;Hello World!&#x27;)

// add a file called my-stream-test.txt from a stream
var entry = pack.entry({ name: &#x27;my-stream-test.txt&#x27;, size: 11 }, function(err) {
  // the stream was added
  // no more entries
  pack.finalize()
})

entry.write(&#x27;hello&#x27;)
entry.write(&#x27; &#x27;)
entry.write(&#x27;world&#x27;)
entry.end()

// pipe the pack stream somewhere
pack.pipe(process.stdout)
```

## Extracting

To extract a stream use `tar.extract()` and listen for `extract.on(&#x27;entry&#x27;, (header, stream, next) )`

``` js
var extract = tar.extract()

extract.on(&#x27;entry&#x27;, function(header, stream, next) {
  // header is the tar header
  // stream is the content body (might be an empty stream)
  // call next when you are done with this entry

  stream.on(&#x27;end&#x27;, function() {
    next() // ready for next entry
  })

  stream.resume() // just auto drain the stream
})

extract.on(&#x27;finish&#x27;, function() {
  // all entries read
})

pack.pipe(extract)
```

The tar archive is streamed sequentially, meaning you **must** drain each entry&#x27;s stream as you get them or else the main extract stream will receive backpressure and stop reading.

## Headers

The header object using in `entry` should contain the following properties.
Most of these values can be found by stat&#x27;ing a file.

``` js
{
  name: &#x27;path/to/this/entry.txt&#x27;,
  size: 1314,        // entry size. defaults to 0
  mode: 0o644,       // entry mode. defaults to to 0o755 for dirs and 0o644 otherwise
  mtime: new Date(), // last modified date for entry. defaults to now.
  type: &#x27;file&#x27;,      // type of entry. defaults to file. can be:
                     // file | link | symlink | directory | block-device
                     // character-device | fifo | contiguous-file
  linkname: &#x27;path&#x27;,  // linked file name
  uid: 0,            // uid of entry owner. defaults to 0
  gid: 0,            // gid of entry owner. defaults to 0
  uname: &#x27;maf&#x27;,      // uname of entry owner. defaults to null
  gname: &#x27;staff&#x27;,    // gname of entry owner. defaults to null
  devmajor: 0,       // device major version. defaults to 0
  devminor: 0        // device minor version. defaults to 0
}
```

## Modifying existing tarballs

Using tar-stream it is easy to rewrite paths / change modes etc in an existing tarball.

``` js
var extract = tar.extract()
var pack = tar.pack()
var path = require(&#x27;path&#x27;)

extract.on(&#x27;entry&#x27;, function(header, stream, callback) {
  // let&#x27;s prefix all names with &#x27;tmp&#x27;
  header.name = path.join(&#x27;tmp&#x27;, header.name)
  // write the new entry to the pack stream
  stream.pipe(pack.entry(header, callback))
})

extract.on(&#x27;finish&#x27;, function() {
  // all entries done - lets finalize it
  pack.finalize()
})

// pipe the old tarball to the extractor
oldTarballStream.pipe(extract)

// pipe the new tarball the another stream
pack.pipe(newTarballStream)
```

## Saving tarball to fs


``` js
var fs = require(&#x27;fs&#x27;)
var tar = require(&#x27;tar-stream&#x27;)

var pack = tar.pack() // pack is a streams2 stream
var path = &#x27;YourTarBall.tar&#x27;
var yourTarball = fs.createWriteStream(path)

// add a file called YourFile.txt with the content &quot;Hello World!&quot;
pack.entry({name: &#x27;YourFile.txt&#x27;}, &#x27;Hello World!&#x27;, function (err) {
  if (err) throw err
  pack.finalize()
})

// pipe the pack stream to your file
pack.pipe(yourTarball)

yourTarball.on(&#x27;close&#x27;, function () {
  console.log(path + &#x27; has been written&#x27;)
  fs.stat(path, function(err, stats) {
    if (err) throw err
    console.log(stats)
    console.log(&#x27;Got file info successfully!&#x27;)
  })
})
```

## Performance

[See tar-fs for a performance comparison with node-tar](https://github.com/mafintosh/tar-fs/blob/master/README.md#performance)

# License

MIT
</pre>
</body>
</html>