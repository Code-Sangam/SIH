<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>readme.html</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<pre># undefsafe

Simple *function* for retrieving deep object properties without getting &quot;Cannot read property &#x27;X&#x27; of undefined&quot;

Can also be used to safely set deep values.

## Usage

```js
var object = {
  a: {
    b: {
      c: 1,
      d: [1,2,3],
      e: &#x27;remy&#x27;
    }
  }
};

console.log(undefsafe(object, &#x27;a.b.e&#x27;)); // &quot;remy&quot;
console.log(undefsafe(object, &#x27;a.b.not.found&#x27;)); // undefined
```

Demo: [https://jsbin.com/eroqame/3/edit?js,console](https://jsbin.com/eroqame/3/edit?js,console)

## Setting

```js
var object = {
  a: {
    b: [1,2,3]
  }
};

// modified object
var res = undefsafe(object, &#x27;a.b.0&#x27;, 10);

console.log(object); // { a: { b: [10, 2, 3] } }
console.log(res); // 1 - previous value
```

## Star rules in paths

As of 1.2.0, `undefsafe` supports a `*` in the path if you want to search all of the properties (or array elements) for a particular element.

The function will only return a single result, either the 3rd argument validation value, or the first positive match. For example, the following github data:

```js
const githubData = {
        commits: [{
          modified: [
            &quot;one&quot;,
            &quot;two&quot;
          ]
        }, /* ... */ ]
      };

// first modified file found in the first commit
console.log(undefsafe(githubData, &#x27;commits.*.modified.0&#x27;));

// returns `two` or undefined if not found
console.log(undefsafe(githubData, &#x27;commits.*.modified.*&#x27;, &#x27;two&#x27;));
```
</pre>
</body>
</html>